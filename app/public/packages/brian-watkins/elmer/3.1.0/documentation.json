[
  {
    "name": "Elmer.Http.Stub",
    "comment": " Functions for building stubbed responses to Http requests.\n\n# Create a stubbed response\n@docs for\n\n# Describe the Response body\n@docs withBody\n\n# Describe the Response Status\n@docs withStatus, withError\n\n# Provide a Result based on the Request\n@docs withResult\n\n# Defer the Response\n@docs deferResponse\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "deferResponse",
        "comment": " Defer a response.\n\nThe response will not be processed until `Elmer.Platform.Command.resolveDeferred` is called.\n",
        "type": "Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "for",
        "comment": " Stub the response for a request to the specified route.\n\nBy default, this response will return an empty body with a status of\n`200 OK`.\n",
        "type": "Elmer.Http.Internal.HttpRoute -> Elmer.Http.Internal.HttpResponseStub"
      },
      {
        "name": "withBody",
        "comment": " Build a response stub that returns the specified string as its body.\n\nSuppose you want to describe the behavior that results when a response body is\nparsed. You could create a stub like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.post \"http://fake.com/fake\")\n      |> withBody \"{\\\"name\\\":\\\"Fun Person\\\"}\"\n\n",
        "type": "String -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "withError",
        "comment": " Build a response stub that results in an `Http.Error`.\n\nSuppose you want to describe the behavior that should result when a request\ntimes out. You could create a stubbed response like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.get \"http://fake.com/fake\")\n      |> withError Http.Error.Timout\n\n",
        "type": "Http.Error -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "withResult",
        "comment": " Build a response stub that generates an HttpResult based on the matching\nHttpRequest.\n\nYou could create a stub that echoes back the posted body like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.post \"http://fake.com/fake\")\n      |> withResult (\\request result ->\n        Elmer.Http.Result.withBody (Elmer.Http.Request.body request) result\n      )\n\n",
        "type": "(Elmer.Http.Internal.HttpRequest -> Elmer.Http.Internal.HttpResult -> Elmer.Http.Internal.HttpResult) -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "withStatus",
        "comment": " Build a response stub that returns some particular status.\n\nSuppose you want to describe the behavior that should result when a request\nreturns a `500 Internal Server Error`. You could create a stubbed response like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.get \"http://fake.com/fake\")\n      |> withStatus Elmer.Http.Status.serverError\n\n",
        "type": "Elmer.Http.Internal.HttpStatus -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Http",
    "comment": " Functions for handling Http requests in your tests.\n\nYour component makes Http requests. You want to describe the behavior of your\ncomponent. What to do?\n\n1. Create an HttpResponseStub -- see `Elmer.Http.Stub`\n\n2. Serve it up during your test\n\n3. Smile!\n\n# Serve Stubbed Responses\n@docs HttpResponseStub, serve, spy\n\n# Make Expectations about Http Requests\n@docs expect, expectThat, clearRequestHistory\n\n",
    "aliases": [
      {
        "name": "HttpResponseStub",
        "comment": " Represents a stubbed HttpResponse\n\nUse `Elmer.Http.Stub` to build an `HttpResponseStub`.\n",
        "args": [],
        "type": "Elmer.Http.Internal.HttpResponseStub"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "clearRequestHistory",
        "comment": " Clear any Http requests that may have been recorded at an earlier point\nin the history of this TestState.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "expect",
        "comment": " Expect one or more requests to the specified route.\n\n    expect (Elmer.Http.Route.get \"http://fun.com/fun.html\")\n\nIf no requests have been made to the specified route, the test will fail.\n\nNote: This must be used in conjunction with `Elmer.Http.serve` or `Elmer.Http.spy`.\n",
        "type": "Elmer.Http.Internal.HttpRoute -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "expectThat",
        "comment": " Make some expectation about requests to the specified route.\n\n    expectThat (Elmer.Http.Route.get \"http://fun.com/fun\") (\n      Elmer.each <| Elmer.Http.Matchers.hasHeader (\"X-Auth-Token\", \"MY-TOKEN\")\n    )\n\nIf no requests have been made to the specified route, an empty list\nwill be passed to the `Matcher (List HttpRequest)`.\n\nNote: This must be used in conjunction with `Elmer.Http.serve` or `Elmer.Http.spy`.\n",
        "type": "Elmer.Http.Internal.HttpRoute -> Elmer.Matcher (List Elmer.Http.Internal.HttpRequest) -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "serve",
        "comment": " Override `Http.send` and register HttpResponseStubs to be returned\nwhen the appropriate request is received. Used in conjunction with\n`Elmer.Spy.use`.\n\nSuppose you have a component that requests information about a user when\na button is clicked. You could register a stub for that request like so\n\n    let\n      stubbedResponse = Elmer.Http.Stub.for (Elmer.Http.Route.post \"http://fun.com/user\")\n        |> Elmer.Http.Stub.withBody\n          \"{\\\"name\\\":\\\"Super User\\\",\\\"type\\\":\\\"admin\\\"}\"\n    in\n      testState\n        |> Spy.use [ serve [ stubbedResponse ] ]\n        |> Markup.target \"#request-data-button\"\n        |> Elmer.Html.Event.click\n        |> Markup.target \"#data-result\"\n        |> Markup.expect (Matchers.element <| Matchers.hasText \"Hello, Super User!\")\n\n",
        "type": "List Elmer.Http.HttpResponseStub -> Elmer.Spy.Spy"
      },
      {
        "name": "spy",
        "comment": " Override `Http.send` and record requests as they are received.\nUsed in conjunction with `Elmer.Spy.use`.\n\nSuppose you simply want to make an expectation about a request without\ndescribing the behavior that results when its response is received.\n\n    testState\n      |> Spy.use [ spy ]\n      |> Markup.target \"#request-data-button\"\n      |> Elmer.Http.Event.click\n      |> Elmer.Http.expect (Elmer.Http.Route.get \"http://fun.com/user\")\n\n",
        "type": "Elmer.Spy.Spy"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Spy.Matchers",
    "comment": " Matchers for making expectations about Spies.\n\n# General Expectations\n@docs wasCalled, wasCalledWith\n\n# Expectations About Calls\n@docs Call, calls, hasArgs\n\n# Argument Matchers\n@docs Arg, anyArg, stringArg, intArg, floatArg, boolArg, typedArg, functionArg\n\n",
    "aliases": [
      {
        "name": "Arg",
        "comment": " Represents an expected function argument.\n",
        "args": [],
        "type": "Elmer.Spy.Internal.Arg"
      },
      {
        "name": "Call",
        "comment": " Represents a particular call to a spy.\n",
        "args": [],
        "type": "List Elmer.Spy.Matchers.Arg"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "anyArg",
        "comment": " Matches any argument.\n",
        "type": "Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "boolArg",
        "comment": " Matches an argument with the given boolean value.\n",
        "type": "Bool -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "calls",
        "comment": " Make expectations about the calls recorded by this spy.\n\nHere's how you would expect that exactly 2 of the calls had a certain argument.\n\n    Spy.expect \"my-spy\" (\n      calls <| exactly 2 <|\n        hasArgs\n        [ stringArg \"some argument\"\n        ]\n    )\n\n",
        "type": "Elmer.Matcher (List Elmer.Spy.Matchers.Call) -> Elmer.Matcher Elmer.Spy.Calls"
      },
      {
        "name": "floatArg",
        "comment": " Matches an argument with the given float value.\n",
        "type": "Float -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "functionArg",
        "comment": " Matches an argument that is a function.\n",
        "type": "Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "hasArgs",
        "comment": " Expect that a call has some arguments.\n\nUsed in conjunction with `calls`.\n",
        "type": "List Elmer.Spy.Matchers.Arg -> Elmer.Matcher Elmer.Spy.Matchers.Call"
      },
      {
        "name": "intArg",
        "comment": " Matches an argument with the given integer.\n",
        "type": "Int -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "stringArg",
        "comment": " Matches an argument with the given string.\n",
        "type": "String -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "typedArg",
        "comment": " Matches an argument with the given typed value.\n\nNote: You may not match what you want if your typed value contains a function reference.\n",
        "type": "a -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "wasCalled",
        "comment": " Expect that a spy was called some number of times.\n\nThis is shorthand for:\n\n    Spy.expect \"my-spy\" (calls <| hasLength 2)\n\n",
        "type": "Int -> Elmer.Matcher Elmer.Spy.Calls"
      },
      {
        "name": "wasCalledWith",
        "comment": " Expect that a spy was called at least once with the given arguments.\n\n    Spy.expect \"my-spy\" (\n      wasCalledWith\n        [ stringArg \"Some String\"\n        , typedArg someTypedValue\n        ]\n    )\n\nThis is shorthand for:\n\n    Spy.expect \"my-spy\" (\n      calls <| some <| hasArgs\n        [ stringArg \"Some String\"\n        , typedArg someTypedValue\n        ]\n    )\n\n",
        "type": "List Elmer.Spy.Matchers.Arg -> Elmer.Matcher Elmer.Spy.Calls"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Navigation",
    "comment": " Functions for describing the behavior of components that use\n[elm-lang/navigation](http://package.elm-lang.org/packages/elm-lang/navigation/latest/Navigation).\n\n# Register the location parser\n@docs withLocationParser\n\n# Update the Location\n@docs setLocation\n\n# Make Expectations about the Location\n@docs spy, expectLocation\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "expectLocation",
        "comment": " Expect that the current location is equal to the given string.\n\nNote: This expectation must be used in conjunction with `spy` above.\n",
        "type": "String -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "setLocation",
        "comment": " Set the location for the component.\n\nWhen the location is set and a location parser is defined for this component,\nthen the parser will be applied to the location and the resulting message\nwill be passed to the component's `update` function for processing.\n",
        "type": "String -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "spy",
        "comment": " Stub `Navigation.newUrl` and `Navigation.modifyUrl` with a function that\nrecords the location as it is set.\n\nYou must use this function with `Elmer.Spy.use` in order to make expectations\nabout the location.\n\nSuppose you want to test a home button that sets the\nlocation to `/home` when clicked:\n\n    testState\n      |> Spy.use [ Navigation.spy ]\n      |> Elmer.Html.target \"#home-button\"\n      |> Elmer.Html.Event.click\n      |> Navigation.expectLocation \"/home\"\n\n",
        "type": "Elmer.Spy.Spy"
      },
      {
        "name": "withLocationParser",
        "comment": " Register a location parser with the current test context.\n\nThe location parser function is the function you would provide to\n`Navigation.program` when you initialize your app.\n",
        "type": "(Navigation.Location -> msg) -> Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Platform.Subscription",
    "comment": " Functions for dealing with subscriptions during your test.\n\nElmer allows you to manage the effects of subscriptions yourself, so you can\ndescribe the behavior of a component under whatever conditions you need.\n\nTo manage the effects of a subscription, you'll need to do three things.\n\n1. Stub the function in your code that produces the subscription so that\nit returns a fake subscription.\n\n2. Use `with` to register the subscription during your test.\n\n2. Use `send` to send data for that subscription to your component.\n\n3. Enjoy.\n\nNote: Elmer supports `Platform.Sub.batch` and `Platform.Sub.map` so you can use these in your\ncomponent as expected.\n\n# Register Subscriptions\n@docs with\n\n# Create a Fake Subscription\n@docs fake\n\n# Send Data for a Subscription\n@docs send\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "fake",
        "comment": " Generate a fake subscription with an identifier and the appropriate tagger.\n\nUse `Elmer.Platform.spy` along with `Elmer.Platform.andCallFake` to stub a function\nthat generates a subscription so that it returns a fake instead. Then, once\nthe faked subscription is registered using `with`,\nyou can `send` data on behalf of it subscription during your test.\n\nHere's an example that creates a fake subscription for mouse ups, registers it\nand sends some data through it.\n\n    let\n      subSpy = Elmer.Platform.spy \"fake-ups\" (\\_ -> Mouse.ups)\n        |> Elmer.Platform.andCallFake (\\tagger ->\n          Subscription.fake \"mouseUps\" tagger\n        )\n    in\n      Elmer.given defaultModel view update\n        |> Spy.use [ subSpy ]\n        |> with (\\() -> subscriptions)\n        |> send \"mouseUps\" { x = 10, y = 50 }\n\n",
        "type": "String -> (a -> msg) -> Platform.Sub.Sub msg"
      },
      {
        "name": "send",
        "comment": " Send data on behalf of the identified subscription.\n\nData sent via this function will be tagged accordingly and passed to\nthe component's `update` function for processing.\n",
        "type": "String -> a -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "with",
        "comment": " Register fake subscriptions for use during your test.\n\nSuppose your component updates the view with the new time every second. To\nget the time every second, in your code you'll need to create a `subscriptions`\nfunction that returns `Time.every Time.second <tagger>`. To describe this behavior in your test, you\ncould do the following:\n\n    let\n      fakeSub = Elmer.Platform.spy \"fake-time\" (\\_ -> Time.every)\n        |> Elmer.Platform.andCallFake (\\interval tagger ->\n          Elmer.Platform.Subscription.fake \"everySecond\" tagger\n        )\n    in\n      testState\n        |> Spy.use [ fakeSub ]\n        |> with (\\() -> Component.subscriptions)\n        |> send \"everySecond\" 3000\n        |> target \"#current-time\"\n        |> Elmer.Html.expect (element <| hasText \"3 seconds\")\n\n",
        "type": "(() -> model -> Platform.Sub.Sub msg) -> Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Html.Matchers",
    "comment": " Make expectations about the Html generated by the component's view function.\n\n# HtmlTarget Matchers\n@docs element, elementExists, elements\n\n# HtmlElement Matchers\n@docs hasText, hasId, hasClass, hasStyle, hasAttribute, hasProperty, listensForEvent\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "element",
        "comment": " Make expectations about the selected element.\n\nThe matcher will fail if the selected element does not exist.\n\nIf the selector matches more than one element,\nthe given element matcher will only be applied to the first element selected.\n\n    Elmer.Html.target \"div\"\n      |> Elmer.Html.expect (element <| hasText \"Fun Stuff\")\n\n",
        "type": "Elmer.Matcher (Elmer.Html.HtmlElement msg) -> Elmer.Matcher (Elmer.Html.HtmlTarget msg)"
      },
      {
        "name": "elementExists",
        "comment": " Expect that the selected element exists.\n\n    Elmer.Html.target \"#cool-element\" testState\n      |> Elmer.Html.expect elementExists\n",
        "type": "Elmer.Matcher (Elmer.Html.HtmlTarget msg)"
      },
      {
        "name": "elements",
        "comment": " Make expectations about the selected elements.\n\nIf the selector fails to match any elements, an empty list will\nbe passed to the given matcher.\n\n    Elmer.Html.target \"li\" testState\n      |> Elmer.Html.expect (elements <| Elmer.hasLength 4)\n\n",
        "type": "Elmer.Matcher (List (Elmer.Html.HtmlElement msg)) -> Elmer.Matcher (Elmer.Html.HtmlTarget msg)"
      },
      {
        "name": "hasAttribute",
        "comment": " Expect that an element has the specified attribute with the specified value.\n\n    hasAttribute ( \"src\", \"http://fun.com\" ) element\n\n",
        "type": "( String, String ) -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "hasClass",
        "comment": " Expect that an element has the specified class. No need to prepend the class name with a dot.\n",
        "type": "String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "hasId",
        "comment": " Expect that an element has the specified id. No need to prepend the id with a pound sign.\n",
        "type": "String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "hasProperty",
        "comment": " Expect that an element has the specified property with the specified value.\n\n    hasProperty ( \"innerHtml\", \"Fun <i>stuff</i>\" ) element\n\n",
        "type": "( String, String ) -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "hasStyle",
        "comment": " Expect that an element has the specified style.\n\n    hasStyle (\"left\", \"20px\") element\n\n",
        "type": "( String, String ) -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "hasText",
        "comment": " Expect that an element has some text. This matcher will pass only if the element\nor any of its descendents contains some `Html.text` with the specified text.\n",
        "type": "String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "listensForEvent",
        "comment": " Expect that an element listens for an event of the given type.\n\n    listensForEvent \"click\" element\n\nNote: This will not consider event handlers on the element's ancestors.\n\n",
        "type": "String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Html.Element",
    "comment": " Functions for working directly with HtmlElements.\n\n# Element Characteristics\n@docs id, classList, property, boolProperty, properties, attributes\n\n# Debugging\n@docs toString\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "attributes",
        "comment": " Get this element's attributes as a `Dict`. If you define a custom attribute\nfor an Html element, you can find it with this function.\n\n    Elmer.given someModel view update\n      |> target \"#some-element\"\n      |> expect (element <| \\element ->\n        attributes element\n          |> Dict.get \"data-attribute\"\n          |> Expect.notEqual Nothing\n      )\n",
        "type": "Elmer.Html.HtmlElement msg -> Dict.Dict String String"
      },
      {
        "name": "boolProperty",
        "comment": " Get the boolean value of a particular property belonging to\nthis element, if that property is defined.\n\nIf the property is defined, but its value is not boolean, then\n`Nothing` is returned.\n",
        "type": "String -> Elmer.Html.HtmlElement msg -> Maybe.Maybe Bool"
      },
      {
        "name": "classList",
        "comment": " Get a list of classes applied to this element.\n",
        "type": "Elmer.Html.HtmlElement msg -> List String"
      },
      {
        "name": "id",
        "comment": " Get the value of the element's `id` attribute, if it is defined.\n",
        "type": "Elmer.Html.HtmlElement msg -> Maybe.Maybe String"
      },
      {
        "name": "properties",
        "comment": " Get this element's properties as a `Dict`.\n\nOn the difference between attributes and properties,\nsee [this](https://github.com/elm-lang/html/blob/master/properties-vs-attributes.md).\n",
        "type": "Elmer.Html.HtmlElement msg -> Dict.Dict String String"
      },
      {
        "name": "property",
        "comment": " Get the value of a particular property belonging to this\nelement, if that property is defined.\n",
        "type": "String -> Elmer.Html.HtmlElement msg -> Maybe.Maybe String"
      },
      {
        "name": "toString",
        "comment": " Represent an `HtmlElement` as a String.\n",
        "type": "Elmer.Html.HtmlElement msg -> String"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Headless",
    "comment": " Functions for testing 'headless' Elm modules\n\n# Test a Worker\n@docs given\n\n# Test a Command\n@docs givenCommand, expectMessages\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "expectMessages",
        "comment": " Make expectations about messages generated by processing a command.\n\n    Elmer.givenCommand (\\() -> MyModule.commandToSendAnHttpRequest someArgument)\n      |> Elmer.Spy.use [ Elmer.Http.serve [ someStubbedResponse ] ]\n      |> Elmer.expectMessages (\n        exactly 1 <| Expect.equal (\n          MyMessage <| Ok \"response from server\"\n        )\n      )\n\nNote that `expectMessages` should only be used in a test initialized\nwith `givenCommand`.\n",
        "type": "Elmer.Matcher (List msg) -> Elmer.Matcher (Elmer.TestState () msg)"
      },
      {
        "name": "given",
        "comment": " Initialize a `TestState` with a model and update function.\n\nUse this function to initialize tests for headless 'worker' programs\ncreated with `Elmer.platform.program` or `Elmer.platform.programWithFlags`.\n",
        "type": "model -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"
      },
      {
        "name": "givenCommand",
        "comment": " Initialize a `TestState` with a command.\n\nA test initialized in this way can use `expectMessages` to examine\nmessages generated when the given command is processed.\n",
        "type": "(() -> Platform.Cmd.Cmd msg) -> Elmer.TestState () msg"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Spy",
    "comment": " Functions for spying during tests.\n\n@docs Spy, Calls\n\n# Spy on a Real Function\n@docs create, andCallFake\n\n# Spy on a Provided Function\n@docs createWith, callable\n\n# Use a Spy\n@docs use\n\n# Make Expectations about a Spy\n@docs expect\n\n",
    "aliases": [
      {
        "name": "Calls",
        "comment": " Represents the calls made to a spy.\n",
        "args": [],
        "type": "Elmer.Spy.Internal.Calls"
      },
      {
        "name": "Spy",
        "comment": " Represents a function that has been spied on.\n",
        "args": [],
        "type": "Elmer.Spy.Internal.Spy"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "andCallFake",
        "comment": " Call the provided function when a Spy is called.\n\nOnce you've created a `Spy`, you can provide a fake implementation like so:\n\n    mySpy =\n      create \"my-spy\" (\\_ -> MyComponent.someFunction)\n        |> andCallFake testImplementation\n\nwhere `testImplementation` is some function with the very same signature as\nthe one being spied upon.\n\nIf you are spying on a function that returns a `Cmd`, then your fake\nshould return one of the fake commands described in `Elmer.Platform.Command`.\n\nFor example, you could override `Task.perform` with a fake command that tags\nsome data like so:\n\n    create \"fake-perform\" (\\_ -> Task.perform)\n      |> andCallFake (\\tagger task ->\n          Elmer.Platform.Command.fake (tagger \"some data\")\n        )\n\nIf you are spying on a function that returns a `Sub`, then your fake should\nreturn a fake subscription; see `Subscription.fake`.\n\nNote: The fake implementation will not be active until you register this spy\nvia `use`.\n\n",
        "type": "(a -> b) -> Elmer.Spy.Spy -> Elmer.Spy.Spy"
      },
      {
        "name": "callable",
        "comment": " Returns a function that records calls to itself and calls through to the function\nassociated with the spy with the given name.\n\nNote: Use `callable` only in conjunction with spies produced using `createWith`; otherwise\nyou'll receive an error.\n",
        "type": "String -> a -> b"
      },
      {
        "name": "create",
        "comment": " Create a spy for a function.\n\nTo create a spy for a function, pass in a string to identify the spy and a function that returns the\nfunction you want spy on.\n\nUse a spy when you want to know that a function was called.\n\nTo use the spy, pass the `Spy` to `use`. When the spied upon function is called,\nElmer will record that it has been called. By defalut, Elmer will then call\nthrough to the original function.\n\n    let\n      mySpy =\n        create \"my-spy\" (\\_ -> MyComponent.someFunction)\n    in\n      use [ mySpy ] testState\n        |> expect \"my-spy\" (wasCalled 0)\n\n",
        "type": "String -> (() -> a) -> Elmer.Spy.Spy"
      },
      {
        "name": "createWith",
        "comment": " Create a spy for a function you provide.\n\nLet's say you're testing a function that has a function for one of its arguments.\nIn your test, you may want to provide some function that simulates certain\nconditions. If you want to assert that the provided function is itself called\nwith certain arguments, use `createWith` to construct a spy for that function.\n\nWhen you pass the spied upon function to the function under test, use `Spy.call`\nwhich will return a version of the function that records its calls.\n\nFor example, let's say you want to inject some dependencies into your update\nfunction to decouple application logic from view logic. You would create a spy\nwith a function you provide for your test. Then, use `Spy.callable` when you want\nto provide a version of the function that will record its calls.\n\n    let\n      spy =\n        createWith \"my-spy\" (tagger ->\n          Command.fake <| tagger \"Success!\"\n        )\n      updateForTest =\n        MyModule.updateUsing <|\n          Spy.callable \"my-spy\"\n    in\n      Elmer.given testModel MyModule.view updateForTest\n        |> Elmer.Spy.use [ spy ]\n        |> Elmer.Html.target \"input\"\n        |> Elmer.Html.Event.input \"some text\"\n        |> Elmer.Html.target \"button\"\n        |> Elmer.Html.Event.click\n        |> Elmer.Spy.expect \"my-spy\" (\n          Elmer.Spy.Matchers.wasCalledWith\n            [ Elmer.Spy.Matchers.stringArg \"some text\"\n            ]\n        )\n\nNote: Using `andCallFake` with a spy produced via `createWith` will replace the\nprovided function.\n",
        "type": "String -> (a -> b) -> Elmer.Spy.Spy"
      },
      {
        "name": "expect",
        "comment": " Make an expectation about a spy.\n\nSee `Elmer.Spy.Matchers` for matchers to use with this function.\n\n    let\n      mySpy =\n        create \"my-spy\" (\\_ -> MyComponent.someFunction)\n    in\n      use [ mySpy ] testState\n        |> expect \"my-spy\" (wasCalled 0)\n\n",
        "type": "String -> Elmer.Matcher Elmer.Spy.Calls -> Elmer.TestState model msg -> Expect.Expectation"
      },
      {
        "name": "use",
        "comment": " Install spies for use during the test.\n\nSuppose your component contains a button that,\nwhen clicked, issues a command to get the current date and updates the view. To\nget the current date, in your code you'll need to create a `Task` with `Date.now` and then\ngenerate a command with `Task.perform`. To describe this behavior in your test,\nyou could do something like the following:\n\n    let\n      taskOverride =\n        create \"fake-perform\" (\\_ -> Task.perform)\n          |> andCallFake (\\tagger task ->\n            Elmer.Platform.Command.fake (\n              tagger <| toDate \"11/12/2016 5:30 pm\"\n            )\n          )\n    in\n      testState\n        |> use [ taskOverride ]\n        |> Elmer.Html.target \"#get-date\"\n        |> Elmer.Html.Event.click\n        |> Elmer.Html.target \"#current-date\"\n        |> Elmer.Html.expect (\n          Elmer.Html.Matchers.element <|\n            Elmer.Html.Matchers.hasText \"11/12/2016 5:30 pm\"\n        )\n\nNote: If you need to replace a spy during the course of a test, you may\ncall `use` again with the new spy. Each time you call `use` *all* spies\nwill be removed. So be sure that each time you call `use` you register all\nthe spies you need.\n",
        "type": "List Elmer.Spy.Spy -> Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Platform.Command",
    "comment": " Functions for dealing with commands during your tests.\n\nElmer allows you to manage the effects of commands yourself, so you can\ndescribe the behavior of a component under whatever conditions you need.\n\nTo manage the effects of a command, you'll need to do two things.\n\n1. Stub the function in your code that produces the command and replace\nit with a function that returns one of the fake commands described below.\n\n2. Enjoy.\n\nNote: Elmer supports `Platform.Cmd.batch` and `Platform.Cmd.map` so you can use these in your\ncomponent as expected.\n\nNote: Elmer provides special support for commands generated by\n[elm-lang/http](http://package.elm-lang.org/packages/elm-lang/http/latest)\nand [elm-lang/navigation](http://package.elm-lang.org/packages/elm-lang/navigation/latest/Navigation)\n-- See `Elmer.Http` and `Elmer.Navigation`, respectively.\n\n# Fake Commands\n@docs fake, dummy, expectDummy, fail\n\n# Defer a Command\n@docs defer, resolveDeferred\n\n# Send a Fake Command\n@docs send\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "defer",
        "comment": " Defer a command for later processing.\n\nYou might want to describe the behavior that occurs after a command\nis sent but before its effect is processed -- for example, the component could\nindicate that network activity is occurring while waiting for a request to complete.\n\nWhen a deferred command is processed, any effect associated with that command will *not* be sent\nto the component's `update` function until `resolveDeferred` is called.\n",
        "type": "Platform.Cmd.Cmd msg -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "dummy",
        "comment": " Generate a dummy command.\n\nYou might only care to describe the fact that a command has been sent, and not\nthe behavior that may result from its effect. In that case, use a dummy command.\n\nWhen this command is processed, the fact that it occured will be\nrecorded; no message will be passed to the component's `update` function.\nThis will be most useful in conjunction with `expectDummy`.\n",
        "type": "String -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "expectDummy",
        "comment": " Expect that a dummy command with the given identifier has been sent.\n",
        "type": "String -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "fail",
        "comment": " Generate a command that will cause the test to fail with the specified message.\n",
        "type": "String -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "fake",
        "comment": " Generate a command that returns a message.\n\nWhen this command is processed, the message will be passed\nto the component's `update` function.\n",
        "type": "msg -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "resolveDeferred",
        "comment": " Resolve any deferred commands.\n\nOnce this function is called, all messages associated with deferred commands will be\nsent to the component's `update` function.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "send",
        "comment": " Send a command.\n\nUse this function to send a command to your component. Any effect associated with this\ncommand will be processed accordingly. Elmer only knows how to process the fake commands\ndescribed above.\n\nThe first argument is a function that returns the command to be sent.\nWe do this to allow Elmer to evaluate the command-generating function lazily,\nin case any stubbed functions need to be applied.\n\n    testState\n      |> send (\\() -> MyComponent.generateSomeCommand)\n      |> Elmer.Html.target \".some-class\"\n      |> Elmer.Html.expect Elmer.Html.Matchers.elementExists\n\n",
        "type": "(() -> Platform.Cmd.Cmd msg) -> Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Html",
    "comment": " Functions for working with the `Html msg` generated by the component's view function.\n\n# Target Html Elements\n@docs HtmlTarget, HtmlElement, target\n\n# Make Expectations\n@docs expect\n\n# Render the View\n@docs render\n\n",
    "aliases": [
      {
        "name": "HtmlElement",
        "comment": " Represents an Html element.\n",
        "args": [
          "msg"
        ],
        "type": "Elmer.Html.Types.HtmlElement msg"
      },
      {
        "name": "HtmlTarget",
        "comment": " Represents the Html Element or Elements about which expectations will be made.\n\nAn `HtmlTarget` is determined by the last use of `Elmer.Html.target`.\n",
        "args": [
          "msg"
        ],
        "type": "Elmer.Html.Query.HtmlTarget msg"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "expect",
        "comment": " Make expectations about the targeted html.\n\n    target \".my-class\" testState\n      |> expect (\n        Elmer.Html.Matchers.element <|\n          Elmer.Html.Matchers.hasText \"some text\"\n      )\n\nUse `expect` in conjunction with matchers like `element`, `elementExists`,\nor `elements`.\n",
        "type": "Elmer.Matcher (Elmer.Html.HtmlTarget msg) -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "render",
        "comment": " Call the component's view function with the current model.\n\nSometimes, it may be useful to render the component's view manually. For example,\nif you are spying on some function called by the view function, you'll need to\nrender the view manually before you can make expectations about that spy.\n\nNote: Usually you will not need to render the view manually.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "target",
        "comment": " Target an element or elements within the Html produced by the\ncomponent's `view` function.\n\nUse this function to specify which element will receive an event or which should\nbe the subject of any expectations.\n\nNote: You may provide a selector that does not match any elements.\n\nTarget an element by class:\n\n    target \".some-class-name\"\n\nTarget an element by id:\n\n    target \"#some-id\"\n\nTarget an element by Html tag:\n\n    target \"div\"\n\nTarget an element by Html tag having attribute:\n\n    target \"div[data-my-attr]\"\n\nTarget an element by Html tag having attribute with value:\n\n    target \"div[data-my-attr='my-value']\"\n\nTarget an element having an attribute:\n\n    target \"[data-my-attr]\"\n\nTarget an element with an attribute and value:\n\n    target \"[data-my-attr='my-value']\"\n\nTarget the first descendant:\n\n    target \"selector1 selector2\"\n\nThis will target the first element that matches `selector2` and is a\ndescendant of the element matching `selector1`, where these selectors follow\nthe syntax described above. For example,\n\n    target \"div a\"\n\nwill target the first `a` element that is a descendant of the first `div` element.\nYou can add as many selectors as you want.\n",
        "type": "String -> Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Html.Event",
    "comment": " Trigger events on targeted elements. When an event occurs, Elmer will\ncall the component's `update` method with the resulting message.\n\nElmer respects the `stopPropagation` option on event handlers. An event on an\nelement will bubble up through that element's ancestors until an event handler\nsays otherwise.\n\nThis means, for example, that you can `click` a targeted element whose\nancestor registers for click events and the event will be handled by that\nancestor as expected.\n\nThe `mouseEnter` and `mouseLeave` events are exceptions to this rule. These events only\ntrigger a handler attached to the targeted element. See `moveMouseIn` and `moveMouseOut`\nfor more.\n\n# Mouse Events\n\nAll mouse events occur at a simulated position of `{ pageX = 0, pageY = 0}`. If your\ntest needs a mouse event to occur at a specific position, use `trigger`.\n\n@docs click, doubleClick, press, release, moveMouseIn, moveMouseOut\n\n# Form Events\n@docs input, check, uncheck, select\n\n# Focus Events\n@docs focus, blur\n\n# Custom Events\n@docs trigger\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "blur",
        "comment": " Trigger a blur event on the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "check",
        "comment": " Trigger a change event on the targeted checkbox element with\n`True` for the `checked` property.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "click",
        "comment": " Simulate a click on the targeted element.\n\nA click will trigger the appropriate `click`, `mouseDown`, and `mouseUp` event\nhandlers on the targeted element or its ancestors.\n\nA click on an input element with type submit or a button element with type submit (or\na button with no type specified) will also trigger the appropriate `submit` event handlers as follows:\n- If the targeted element has a form attribute, then the submit handler\non the specified form will be triggered; if the specified form does not exist, no submit\nhandlers will be triggered.\n- If the targeted element has no form attribute, then the submit handler on any form that is an\nancestor of the targeted element will be triggered.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "doubleClick",
        "comment": " Simulate a double click on the targeted element.\n\nTwo clicks will occur in succession, with the second also triggering a double\nclick event. See `click` above for a list of the events triggered by a click.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "focus",
        "comment": " Trigger a focus event on the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "input",
        "comment": " Trigger an input event on the targeted element.\n",
        "type": "String -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "moveMouseIn",
        "comment": " Simulate moving the mouse into the targeted element.\n\nThis may trigger any relevant `mouseOver` or `mouseEnter` event handlers.\n\nNote: Mouse enter events do not propagate, so a mouse enter action will only\ntrigger an event handler that is registered by the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "moveMouseOut",
        "comment": " Simulate moving the mouse out of the targeted element.\n\nThis may trigger any relevant `mouseOut` or `mouseLeave` event handlers.\n\nNote: Mouse leave events do not propagate, so a mouse leave action will only\ntrigger an event handler that is registered by the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "press",
        "comment": " Trigger a mouse down event on the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "release",
        "comment": " Trigger a mouse up event on the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "select",
        "comment": " Trigger an input event on the targeted select element.\n\nThe argument specifies the option to select by its `value` property.\n",
        "type": "String -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "trigger",
        "comment": " Trigger a custom event on the targeted element. Provide the name of the event\nand the proper representation of the event object in JSON format.\n\nThe following will trigger a `keyup` event:\n\n    testState\n      |> trigger \"keyup\" \"{\\\"keyCode\\\":65}\"\n",
        "type": "String -> String -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "uncheck",
        "comment": " Trigger a change event on the targeted checkbox element with\n`False` for the `checked` property.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Http.Matchers",
    "comment": " Make expectations about Http requests sent by the component under test.\n\nThese matchers should be used with `Elmer.Http.expectGET` etc.\n\nNote: Your test must use `Elmer.Http.serve` or `Elmer.Http.spy` at the\nappropriate time to allow Elmer to record the requests sent by the component\nunder test.\n\n# Matchers\n@docs wasRequested, hasBody, hasQueryParam, hasHeader\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "hasBody",
        "comment": " Match a request with the specified body.\n\n    Elmer.Http.expectThat (Elmer.Http.Route.post \"http://fake.com/fake\") (\n      Elmer.some <| hasBody \"{\\\"name\\\":\\\"Fun Person\\\"}\"\n    )\n\n",
        "type": "String -> Elmer.Matcher Elmer.Http.Request.HttpRequest"
      },
      {
        "name": "hasHeader",
        "comment": " Match a request with the specified header name and value.\n\n    Elmer.Http.expectThat (Elmer.Http.Route.get \"http://fake.com/fake\") (\n      Elmer.some <| hasHeader ( \"x-auth-token\", \"xxxxx\" )\n    )\n\n",
        "type": "( String, String ) -> Elmer.Matcher Elmer.Http.Request.HttpRequest"
      },
      {
        "name": "hasQueryParam",
        "comment": " Match a request that has a query string containing the specified name and value.\n\nNote: You don't need to worry about url encoding the name or value.\n\n    Elmer.Http.expectThat (Elmer.Http.Route.get \"http://fake.com/fake\") (\n      Elmer.some <| hasQueryParam ( \"name\", \"Fun Person\" )\n    )\n\n",
        "type": "( String, String ) -> Elmer.Matcher Elmer.Http.Request.HttpRequest"
      },
      {
        "name": "wasRequested",
        "comment": " Expect that exactly some number of requests have been recorded.\n\n    Elmer.Http.expectThat (Elmer.Http.Route.get \"http://fun.com/fun.html\") (\n      wasRequested 3\n    )\n",
        "type": "Int -> Elmer.Matcher (List Elmer.Http.Request.HttpRequest)"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Http.Status",
    "comment": " Functions for working with Http status codes.\n\n# General\n@docs HttpStatus, httpStatus\n\n# Common Status Codes\n@docs ok, created, unauthorized, forbidden, notFound, serverError\n\n",
    "aliases": [
      {
        "name": "HttpStatus",
        "comment": " Represents the status of an Http response\n",
        "args": [],
        "type": "Elmer.Http.Internal.HttpStatus"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "created",
        "comment": " The `201 Created` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "forbidden",
        "comment": " The `403 Forbidden` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "httpStatus",
        "comment": " Generate an `HttpStatus`.\n",
        "type": "Int -> String -> Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "notFound",
        "comment": " The `404 Not Found` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "ok",
        "comment": " The `200 OK` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "serverError",
        "comment": " The `500 Internal Server Error` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "unauthorized",
        "comment": " The `401 Unauthorized` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer",
    "comment": " Basic types and functions for working with tests and matchers\n\n# Initializing a test\n@docs TestState, given\n\n# Make low-level expectations\n@docs expectModel\n\n# Test an init method\n@docs init\n\n# Working with Matchers\n@docs Matcher, (<&&>), expectNot\n\n# List Matchers\n@docs each, exactly, some, atIndex, hasLength\n\n",
    "aliases": [
      {
        "name": "Matcher",
        "comment": " Generic type for functions that pass or fail.\n\nA matcher returns an `Expect.Expectation` from the\n[elm-test](http://package.elm-lang.org/packages/elm-community/elm-test/latest)\npackage.\n",
        "args": [
          "a"
        ],
        "type": "a -> Expect.Expectation"
      },
      {
        "name": "TestState",
        "comment": " Represents the current state of the test.\n",
        "args": [
          "model",
          "msg"
        ],
        "type": "Elmer.TestState.TestState model msg"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "<&&>",
        "comment": " Operator for conjoining matchers.\nIf one fails, then the conjoined matcher fails, otherwise it passes.\n\n    Elmer.given someModel view update\n      |> Elmer.Html.expect (\n        Elmer.Html.Matchers.element <|\n          Elmer.Html.Matchers.hasText \"Awesome\" <&&>\n          Elmer.Html.Matchers.hasClass \"cool\"\n        )\n",
        "type": "Elmer.Matcher a -> Elmer.Matcher a -> Elmer.Matcher a"
      },
      {
        "name": "atIndex",
        "comment": " Expect that the item at the given index satisfies the given matcher.\n",
        "type": "Int -> Elmer.Matcher a -> Elmer.Matcher (List a)"
      },
      {
        "name": "each",
        "comment": " Expect that all items in a list satisfy the given matcher.\n",
        "type": "Elmer.Matcher a -> Elmer.Matcher (List a)"
      },
      {
        "name": "exactly",
        "comment": " Expect that exactly some number of items in a list satisfy the given matcher.\n",
        "type": "Int -> Elmer.Matcher a -> Elmer.Matcher (List a)"
      },
      {
        "name": "expectModel",
        "comment": " Make expectations about the model in its current state.\n\n    Elmer.given defaultModel view update\n      |> Elmer.Html.target \"button\"\n      |> Elmer.Html.Event.click\n      |> Elmer.expectModel (\\model ->\n        Expect.equal model.clickCount 1\n      )\n\nUse Elmer to get the model into a certain state. Then use the normal facilities of\nelm-test to describe how the model should look in that state.\n",
        "type": "Elmer.Matcher model -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "expectNot",
        "comment": " Expect that a matcher fails.\n",
        "type": "Elmer.Matcher a -> Elmer.Matcher a"
      },
      {
        "name": "given",
        "comment": " Initialize a test with a model, view function, and update function.\n",
        "type": "model -> (model -> Html.Html msg) -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"
      },
      {
        "name": "hasLength",
        "comment": " Expect that a list has the given length.\n",
        "type": "Int -> Elmer.Matcher (List a)"
      },
      {
        "name": "init",
        "comment": " Update the test context with the given model and Cmd.\n\nThe current model will be replaced by the given model and the given command\nwill then be executed. This is most useful for testing `init` functions.\n\nThe first argument takes a wrapper around whatever function produces the initial\nmodel and command. This allows Elmer to evaluate the initializing function lazily,\nin case any stubs need to be applied.\n\n    Elmer.given MyComponent.defaultModel MyComponent.view MyComponent.update\n      |> init (\\() -> MyComponent.init)\n      |> Elmer.Html.target \"#title\"\n      |> Elmer.Html.expectElementExists\n\n",
        "type": "(() -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "some",
        "comment": " Expect that at least one item in a list satisfies the given matcher.\n",
        "type": "Elmer.Matcher a -> Elmer.Matcher (List a)"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Http.Request",
    "comment": " Functions for working with a recorded HTTP request.\n\n@docs HttpRequest, body\n\n",
    "aliases": [
      {
        "name": "HttpRequest",
        "comment": " Represents a recorded HTTP request about which expectations may be made.\n",
        "args": [],
        "type": "Elmer.Http.Internal.HttpRequest"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "body",
        "comment": " Get the body of a recorded HTTP request.\n",
        "type": "Elmer.Http.Request.HttpRequest -> Maybe.Maybe String"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Http.Result",
    "comment": " Functions for working with the stubbed result of an HTTP request.\n\n@docs HttpResult, withBody\n\n",
    "aliases": [
      {
        "name": "HttpResult",
        "comment": " Represents the stubbed result of an HTTP request.\n",
        "args": [],
        "type": "Elmer.Http.Internal.HttpResult"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "withBody",
        "comment": " Set the body of an HttpResult.\n\nIf the given HttpResult is set to return an error, then this function\nwill do nothing. \n",
        "type": "String -> Elmer.Http.Result.HttpResult -> Elmer.Http.Result.HttpResult"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Elmer.Http.Route",
    "comment": " Functions for working with HTTP routes.\n\nA route is an HTTP request method plus a URL, up to but not including a query string.\n\n# Creating an HttpRoute\n@docs HttpRoute, get, post, delete, put, patch\n\n# Accessing an HttpRoute\n@docs method, url\n\n",
    "aliases": [
      {
        "name": "HttpRoute",
        "comment": " Represents an HTTP route, which is a URL plus an HTTP request method.\n",
        "args": [],
        "type": "Elmer.Http.Internal.HttpRoute"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "delete",
        "comment": " Create a route for an HTTP DELETE.\n\n    delete \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "get",
        "comment": " Create a route for an HTTP GET.\n\n    get \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "method",
        "comment": " Return the route's method.\n",
        "type": "Elmer.Http.Route.HttpRoute -> String"
      },
      {
        "name": "patch",
        "comment": " Create a route for an HTTP PATCH.\n\n    patch \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "post",
        "comment": " Create a route for an HTTP POST.\n\n    post \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "put",
        "comment": " Create a route for an HTTP PUT.\n\n    put \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "url",
        "comment": " Return the route's url.\n",
        "type": "Elmer.Http.Route.HttpRoute -> String"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]